#ifndef GC_HPP
#define GC_HPP

#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <assert.h>

#include "util.hpp"

class Handle;
class RawObject;
class Object;
class FrameDescr;
class ThreadState;

// Pads object, stores gc-related info
class GcHeader {
 public:
  enum {
    kCopied
  };

  static intptr_t fromRuntimeAlloc(size_t size);

  static GcHeader *fromRawObject(RawObject *wat) {
    return reinterpret_cast<GcHeader *>(
        reinterpret_cast<intptr_t>(wat) - sizeof(GcHeader));
  }

  RawObject *toRawObject() const {
    return reinterpret_cast<RawObject *>(
        reinterpret_cast<intptr_t>(this) + sizeof(*this));
  }

  template <int n>
  bool markAt() {
    return (1UL << n) & mark;
  }

  template <int n, bool p>
  void setMarkAt() {
    if (p) {
      mark |= (1UL << n);
    }
    else {
      mark &= ~(1UL << n);
    }
  }

  uint32_t mark;

  // Including gcheader
  uint32_t size;

  GcHeader *copiedTo;

  friend class ThreadState;
};

// Stores all the of runtime information
// Like capability in Haskell, ikpcb in Ikarus, etc etc..
class ThreadState {
 public:
  enum {
    kLastFrameDescrOffset,
    kFirstStackPtrOffset,
    kLastStackPtrOffset,
    kHeapPtrOffset,
    kHeapLimitOffset,
    kHeapBaseOffset,
    kHeapSizeOffset,
    kHeapFromSpaceOffset,
    kHeapToSpaceOffset,
    kHeapCopyPtrOffset,
    kLastAllocReqOffset,
    kHandleHeadOffset,
    kSymbolInternTableOffset,
    kLastOffset
  };

  static ThreadState &global() {
    if (!global_) {
      initGlobalState();
    }
    return *global_;
  }

  static void initGlobalState();

  static ThreadState *create();
  void destroy();
  void display(int fd);

  template <typename T>
  T as() {
    return reinterpret_cast<T>(this);
  }

  template <int offset, typename T>
  T &at() {
    return *reinterpret_cast<T *>(as<intptr_t>() + offset);
  }


  void *initGcHeader(intptr_t raw, size_t size);

  // Only used by compiler code.
  void *gcAlloc(size_t size) {
    assert(Util::isAligned<4>(size));
    intptr_t res = heapPtr();
    size += sizeof(GcHeader);
    heapPtr() += size;
    if (//0 &&
        heapPtr() <= heapLimit()) {
      return initGcHeader(res, size);
    }
    else {
      return gcAllocSlow(size);
    }
  }

  void *gcAllocSlow(size_t);
  void gcCollect();
  void gcScavenge(Object **);
  void gcScavengeSchemeStack();

  bool isInToSpace(GcHeader *h) {
    auto raw = reinterpret_cast<intptr_t>(h);
    return heapToSpace() <= raw && raw < heapToSpace() + heapSize();
  }

#define MK_ATTR(name, offset, type) \
  type &name() { return at<offset ## Offset * sizeof(void *), type>(); }

#define ATTR_LIST(V)                                                          \
  V(lastFrameDescr,            kLastFrameDescr,            FrameDescr)        \
  V(firstStackPtr,             kFirstStackPtr,             intptr_t)          \
  V(lastStackPtr,              kLastStackPtr,              intptr_t)          \
  V(heapPtr,                   kHeapPtr,                   intptr_t)          \
  V(heapLimit,                 kHeapLimit,                 intptr_t)          \
  V(heapBase,                  kHeapBase,                  intptr_t)          \
  V(heapSize,                  kHeapSize,                  intptr_t)          \
  V(heapFromSpace,             kHeapFromSpace,             intptr_t)          \
  V(heapToSpace,               kHeapToSpace,               intptr_t)          \
  V(heapCopyPtr,               kHeapCopyPtr,               intptr_t)          \
  V(lastAllocReq,              kLastAllocReq,              size_t)            \
  V(handleHead,                kHandleHead,                Handle *)          \
  V(symbolInternTable,         kSymbolInternTable,         Object *)          \
  // Append

  ATTR_LIST(MK_ATTR);

#undef ATTR_LIST
#undef MK_ATTR

 private:
  static ThreadState *global_;
};

// Generated by codegen for each callsite.
// Currently only contains the size of the frame and the place
// of the pointers
struct FrameDescr {
  uint16_t frameSize;
  char ptrBitMap[6];

  FrameDescr() {
    *this = unpack(0);
  }

  bool isPtr(intptr_t ix) {
    int nthByte = ix >> 3;
    int nthBit = ix & 7;
    return (ptrBitMap[nthByte] >> nthBit) & 1L;
  }

  void setIsPtr(intptr_t ix) {
    int nthByte = ix >> 3;
    int nthBit = ix & 7;
    ptrBitMap[nthByte] |= (1L << nthBit);
  }

  intptr_t pack() {
    return *reinterpret_cast<intptr_t *>(this);
  }

  static FrameDescr unpack(intptr_t val) {
    return *reinterpret_cast<FrameDescr *>(&val);
  }
};

// Used by C++-compiled code (but not by native code) to handle gc.
class Handle {
 public:
  Handle() {
    initPtr(NULL);
  }

  Handle(Object *ptr) {
    initPtr(ptr);
  }

  Handle(const Handle &other) {
    initPtr(other.ptr);
  }

  Handle &operator=(const Handle &other) {
    ptr = other.ptr;
    return *this;
  }

  bool operator==(const Handle &other) const {
    return ptr == other.ptr;
  }

  bool operator==(const Object *other) const {
    return ptr == other;
  }

  ~Handle() {
    prev->next = next;
    next->prev = prev;
  }

  // This
  Object *operator->() const {
    return ptr;
  }

  Object *getPtr() const {
    return ptr;
  }

  operator bool() const {
    return ptr != NULL;
  }

  operator Object *() const {
    return ptr;
  }

  void initPtr(Object *ptr) {
    Handle *&head = ThreadState::global().handleHead();
    this->ptr = ptr;

    // insert before head
    prev = head->prev;
    next = head;

    head->prev->next = this;
    head->prev = this;
  }

 private:

  void initFromThreadState(ThreadState *ts) {
    ptr = NULL;
    next = prev = this;
  }

  Handle *prev, *next;
  Object *ptr;

  friend class ThreadState;
};

#endif
